<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>4</storyId>
    <title>Core Backend Setup for Content Reception</title>
    <status>drafted</status>
    <generatedAt>2025-12-09</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-4-core-backend-setup-for-content-reception.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a developer</asA>
    <iWant>a functional backend endpoint to receive text and PDF inputs</iWant>
    <soThat>the frontend can send user content for processing</soThat>
    <tasks>
- [ ] **Task 1: Implement FastAPI Endpoint for Text Upload (AC: 1)**
  - [ ] Subtask 1.1: Define FastAPI endpoint `POST /api/upload/text` in `backend/app/api/upload/`.
  - [ ] Subtask 1.2: Implement logic to receive and acknowledge text content.
- [ ] **Task 2: Implement FastAPI Endpoint for PDF Upload (AC: 2)**
  - [ ] Subtask 2.1: Define FastAPI endpoint `POST /api/upload/pdf` in `backend/app/api/upload/`.
  - [ ] Subtask 2.2: Implement logic to receive and temporarily store the PDF file.
  - [ ] Subtask 2.3: Integrate `backend/app/core/pdf_parser.py` to extract text from the PDF.
- [ ] **Task 3: Implement HTTP Response Handling (AC: 3)**
  - [ ] Subtask 3.1: Ensure endpoints return appropriate HTTP status codes (e.g., 200 OK for success).
- [ ] **Task 4: Write Backend Integration Tests (AC: 1, 2, 3)**
  - [ ] Subtask 4.1: Write integration tests for `POST /api/upload/text` to verify text reception.
  - [ ] Subtask 4.2: Write integration tests for `POST /api/upload/pdf` to verify PDF reception and temporary storage.
  - [ ] Subtask 4.3: Write unit/integration tests to verify correct HTTP status codes are returned.
    </tasks>
  </story>

  <acceptanceCriteria>
1.  Given the backend server is running, when a `POST` request with text content is sent to `/api/upload_text`, then the backend successfully receives and acknowledges the text.
2.  Given the backend server is running, when a `POST` request with a PDF file is sent to `/api/upload_pdf`, then the backend successfully receives and stores the PDF file (e.g., temporarily).
3.  Given the backend is set up, when the frontend sends content, then appropriate HTTP responses (e.g., 200 OK) are returned.
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/prd-QuizZum-2025-12-05.md</path>
        <title>QuizZum - Product Requirements Document</title>
        <section>High-Level API Endpoints</section>
        <snippet>POST /api/upload/text: Accepts plain text for processing.
POST /api/upload/pdf: Accepts a PDF file for processing.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>Project Structure</section>
        <snippet>backend/                  # FastAPI (Python) application
│   ├── app/                  # FastAPI application modules
│   │   ├── api/              # API endpoints (LLM, PDF, Summaries, Quizzes)
│   │   ├── core/             # Core services (LLM client, PDF parser)
...</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture</title>
        <section>API Contracts</section>
        <snippet>All API responses will be in JSON format. Use standard HTTP status codes (e.g., 200 OK, 201 Created, 400 Bad Request, 500 Internal Server Error).</snippet>
      </doc>
      <doc>
        <path>docs/epics-QuizZum-2025-12-05.md</path>
        <title>QuizZum - Epic Breakdown</title>
        <section>Story 1.4: (MVP) Core Backend Setup for Content Reception</section>
        <snippet>User Story: As a developer, I want a functional backend endpoint to receive text and PDF inputs, so that the frontend can send user content for processing.</snippet>
      </doc>
    </docs>
    <code>
      <file>
        <path>backend/app/main.py</path>
        <action>Create</action>
        <reason>The main entry point for the FastAPI application.</reason>
      </file>
      <file>
        <path>backend/app/api/upload/text.py</path>
        <action>Create</action>
        <reason>The endpoint for handling text uploads.</reason>
      </file>
      <file>
        <path>backend/app/api/upload/pdf.py</path>
        <action>Create</action>
        <reason>The endpoint for handling PDF uploads.</reason>
      </file>
      <file>
        <path>backend/app/core/pdf_parser.py</path>
        <action>Create</action>
        <reason>A service for parsing PDF files.</reason>
      </file>
    </code>
    <dependencies>
      <ecosystem>
        <name>Node.js (frontend)</name>
        <package>
          <name>react</name>
          <version>latest</version>
        </package>
        <package>
          <name>next</name>
          <version>latest</version>
        </package>
        <package>
          <name>@chakra-ui/react</name>
          <version>latest</version>
        </package>
        <package>
          <name>@emotion/react</name>
          <version>latest</version>
        </package>
        <package>
          <name>@emotion/styled</name>
          <version>latest</version>
        </package>
        <package>
          <name>framer-motion</name>
          <version>latest</version>
        </package>
      </ecosystem>
      <ecosystem>
        <name>Python (backend)</name>
        <package>
          <name>fastapi</name>
          <version>latest</version>
        </package>
        <package>
          <name>uvicorn</name>
          <version>latest</version>
        </package>
        <package>
          <name>python-multipart</name>
          <version>latest</version>
        </package>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
      <constraint>The project follows a split-repository structure with `frontend` (Next.js) and `backend` (FastAPI).</constraint>
      <constraint>The backend is responsible for all business logic, LLM interactions, and data persistence.</constraint>
      <constraint>All long-running tasks must be handled asynchronously using Celery and Redis.</constraint>
      <constraint>All API responses must be in JSON format and use standard HTTP status codes.</constraint>
      <constraint>Follow the naming conventions and code organization specified in the architecture document.</constraint>
    </constraints>
  <interfaces>
      <interface>
        <name>Text Upload API</name>
        <kind>REST endpoint</kind>
        <signature>POST /api/upload/text</signature>
        <path>backend/app/api/upload/text.py</path>
      </interface>
      <interface>
        <name>PDF Upload API</name>
        <kind>REST endpoint</kind>
        <signature>POST /api/upload/pdf</signature>
        <path>backend/app/api/upload/pdf.py</path>
      </interface>
    </interfaces>
  <tests>
      <standards>
        A layered testing approach will be adopted: Unit, Integration, E2E. Backend integration tests for API endpoints.
      </standards>
      <locations>
        Tests should be co-located with the source code. For example, `backend/app/tests/test_api.py`.
      </locations>
      <ideas>
        - Write integration tests for `POST /api/upload/text` to verify text reception.
        - Write integration tests for `POST /api/upload/pdf` to verify PDF reception and temporary storage.
        - Write unit/integration tests to verify correct HTTP status codes are returned.
      </ideas>
    </tests>
</story-context>
